package JavaWorker;

import MapReduce.Thrift.AutoGenerated.ClientListeningInfo;
import org.apache.commons.lang3.Pair;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

/**
 * Created by msuchock on 31.05.2018.
 */
public class DataSyncWrapper {
    private BlockingQueue<Boolean> serverActionFlag;
    //assignedWork
    private List<ClientListeningInfo> workersConfigurationList;
    //map
    private BlockingQueue<Pair<String,Integer>> pairsAfterMapQueue;
    private Boolean endOfPairsFromMapQueue;
    //registerMapPair
    private Map<String,List<Integer>> myKeyValuesMap;
    //reduce
    private BlockingQueue<Pair<String,String>> resultList;

    public DataSyncWrapper(){
        serverActionFlag = new ArrayBlockingQueue<>(5);
        workersConfigurationList = new ArrayList<>();
        pairsAfterMapQueue = new ArrayBlockingQueue<>(100);
        endOfPairsFromMapQueue = false;
        myKeyValuesMap = new HashMap<>();
        resultList = new ArrayBlockingQueue<>(100);
    }

    public void endOfServerAction(Boolean bool) throws InterruptedException{
        serverActionFlag.put(bool);
    }

    public void waitForServer() throws InterruptedException{
        serverActionFlag.take();
    }

    public synchronized void setWorkersConfigurationListList(List<ClientListeningInfo> workersConfigurationList){
        this.workersConfigurationList = workersConfigurationList;
    }

    public synchronized List<ClientListeningInfo> getWorkersConfigurationList(){
        return workersConfigurationList;
    }

    public void putInPairsAfterMapQueue(Pair<String,Integer> pair) throws InterruptedException{
        pairsAfterMapQueue.put(pair);
    }

    public Pair<String,Integer> takeFromPairsAfterMapQueue() throws InterruptedException{
        return pairsAfterMapQueue.take();
    }

    public synchronized void setEndPairsAfterMapQueue(Boolean end){
        this.endOfPairsFromMapQueue = end;
    }

    public synchronized Boolean IsEndOfPairsAfterMapQueue(){
        return endOfPairsFromMapQueue;
    }

    public synchronized Boolean isPairsAfterMapQueueEmpty(){
        return pairsAfterMapQueue.isEmpty();
    }

    public synchronized void addToMyKeyValuesMap(Pair<String,Integer> kVE){
        if(myKeyValuesMap.get(kVE.left) != null){
            myKeyValuesMap.get(kVE.left).add(kVE.right);
        }else{
            List<Integer> newValuesList = new ArrayList<>();
            newValuesList.add(kVE.right);
            myKeyValuesMap.put(kVE.left,newValuesList);
        }
    }

    public synchronized Map<String,List<Integer>> getMyKeyValuesMap(){
        return myKeyValuesMap;
    }

    public synchronized void addToResultList(String key,String result){
        resultList.add(new Pair<>(key,result));
    }

    public synchronized BlockingQueue<Pair<String,String>> getResultList(){
        return resultList;
    }



}
