package JavaWorker;

import Configuration.WorkerConfiguration;
import MapReduce.Thrift.AutoGenerated.ClientListeningInfo;
import MapReduce.Thrift.AutoGenerated.KeyValueEntity;
import MapReduce.Thrift.AutoGenerated.MapReduceMaster;
import MapReduce.Thrift.AutoGenerated.MapReduceWorker;
import MapReduce.Thrift.MapReduceWorkerHandler;
import Test.TestUtils;
import org.apache.commons.lang3.Pair;
import org.apache.thrift.TException;
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.server.TServer;
import org.apache.thrift.server.TThreadPoolServer;
import org.apache.thrift.transport.*;
import sun.net.util.IPAddressUtil;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.*;

/**
 * Created by suchy on 28.05.2018.
 */

public class JavaWorker {

    private WorkerConfiguration workerConfiguration;

    public JavaWorker(WorkerConfiguration workerConfiguration){
        this.workerConfiguration = workerConfiguration;
    }

    public void start(){
        // creates fixed thread pool
        final ExecutorService es = Executors.newFixedThreadPool(2);

        DataSyncWrapper dataSyncWrapper = new DataSyncWrapper();

        // server callable thread starts to execute
        final Future<Boolean> f1 = es.submit(new ServerCallClass(dataSyncWrapper));
        // client callable thread starts to execute
        final Future<Boolean> f2 = es.submit(new ClientCallClass(dataSyncWrapper));



        try{
            while ( !f1.isDone() && !f2.isDone()){
                Thread.sleep(20);
                // gets value of callable thread if done
                System.out.println("All done!");
                System.out.println("Server ended with success?: " + String.valueOf(f1.get()));
                System.out.println("Client ended with success?: " + String.valueOf(f2.get()));
            }
        } catch (Exception ex){
            System.out.println("Something went wrong with Calls statuses");
        }
    }

    protected class ServerCallClass implements Callable<Boolean>
    {
        DataSyncWrapper dataSyncWrapper;

        protected ServerCallClass(DataSyncWrapper dataSyncWrapper){
            this.dataSyncWrapper = dataSyncWrapper;
        }

        public Boolean call(){
            try{
                MapReduceWorkerHandler handler = new MapReduceWorkerHandler(dataSyncWrapper, workerConfiguration);
                MapReduceWorker.Processor processor = new MapReduceWorker.Processor(handler);

                TServerTransport serverTransport = new TServerSocket(new ServerSocket(workerConfiguration.getListeningPort(),50, InetAddress.getByName(workerConfiguration.getIp())));
                TServer server = new TThreadPoolServer(new TThreadPoolServer.Args(serverTransport).processor(processor));

                System.out.println("Starting the worker server...");
                server.serve(); // infinite loop inside

                System.out.println("Done.");
                return true;
            } catch (UnknownHostException e){
                System.out.println("UnknownHost Exception occurred!");
                e.printStackTrace();
            } catch (TTransportException e) {
                System.out.println("Thrift Transport Exception occurred!");
                e.printStackTrace();
            } finally {
                return false;
            }
        }
    }

    protected class ClientCallClass implements Callable<Boolean>
    {
        DataSyncWrapper dataSyncWrapper;

        protected ClientCallClass(DataSyncWrapper dataSyncWrapper){
            this.dataSyncWrapper = dataSyncWrapper;
        }

        public Boolean call(){
            try{

                //TODO: Tcp client?
                TTransport transport = new TSocket(workerConfiguration.getMasterIp(),workerConfiguration.getMasterPort());
                TProtocol protocol = new TBinaryProtocol(transport);
                MapReduceMaster.Client client = new MapReduceMaster.Client(protocol);

                try{
                    System.out.println("Trying to open connection...");
                    transport.open();
                } catch (TException x) {
                    System.out.println("Exception occurred: Unable to open connection!");
                    x.printStackTrace();
                    return false;
                }
                System.out.println("Client worker on...");

                try{
                    System.out.println("Register...");
                    System.in.read();
                    client.RegisterWorker(ByteBuffer.wrap(IPAddressUtil.textToNumericFormatV4(workerConfiguration.getIp())).getInt(),workerConfiguration.getListeningPort());
                    System.out.println("Register finished");

                    WorkerListManager workerListManager = new WorkerListManager(dataSyncWrapper.getResultList().size(),dataSyncWrapper.getWorkersConfigurationList());
                    //takes from workersQueue till the end (python putting)
                    //additional condition needed (putting last element after add(take()) case)
                    while(!dataSyncWrapper.IsEndOfRegisterWorkersQueue() && dataSyncWrapper.isRegisterWorkersQueueEmpty()){
                        workerListManager.add(dataSyncWrapper.takeFromRegisterWorkersQueue());
                    }

                    //sending to workers and waiting for all threads
                    sendToWorkersAndWait(workerListManager);

                    System.out.println("Finish Map");
                    System.in.read();
                    //mapFinished commuciate to master
                    client.FinishedMap();
                    //waiting for master call and finishing reduce
                    dataSyncWrapper.waitForFinishReduce();
                    System.out.println("Finish Reduce");
                    System.in.read();
                    client.FinishedReduce();
                    System.out.println("Send Results");
                    System.in.read();
                    for(Pair<String,String> pair: dataSyncWrapper.getResultList()){
                        client.RegisterResult(pair.left,pair.right);
                    }
                } finally {
                    transport.close();
                }
            } catch (IOException e){
                System.out.println("Input Exception occurred!");
                e.printStackTrace();
                return false;
            } catch (TException e){
                System.out.println("Thrift Exception occurred!");
                e.printStackTrace();
                return false;
            } catch(InterruptedException e) {
                System.out.println("Execption occureed during waiting for map results");
                e.printStackTrace();
                return false;
            }
            return true;
        }

        private void sendToWorkersAndWait(WorkerListManager workerListManager){
            List<Future<String>> threadListToWairFor = new ArrayList<>();
            ExecutorService executor= Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
            try{
                for (Integer workerId: workerListManager.getKeyValueEntityMap().keySet()){
                    ClientListeningInfo clientInfo = workerListManager.getClientListeningInfo(workerId);
                    NewThread newThread = new NewThread(clientInfo.getPort(),clientInfo.getIp(),workerListManager.getKeyValueEntityList(workerId));
                    Future<String> future = executor.submit(newThread);
                    threadListToWairFor.add(future);
                }
                //wait for all threads
                for(Future<String> fut : threadListToWairFor) {
                    try {
                        //Future.get() waits for task to get completed
                        System.out.println("RegisterMapPair Result::" + fut.get());
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }
                }
            }catch(Exception err){
                err.printStackTrace();
            }
            executor.shutdown(); // once you are done with ExecutorService
        }

        // TODO: ustawienie hosta z pliku konfiguracyjnego na podstawie workerId
        private class NewThread implements Callable{
            int workerId;
            int port;
            int ip;
            List<KeyValueEntity> keyValueEntityList;

            public NewThread(int port, int ip, List<KeyValueEntity> keyValueEntityList){
                this.port = port;
                this.ip = ip;
                this.keyValueEntityList = keyValueEntityList;
            }
            public String call(){
                try{

                    TTransport transport = new TSocket(InetAddress.getByAddress(ByteBuffer.allocate(4).putInt(ip).array()).getHostName(),port);
                    TProtocol protocol = new TBinaryProtocol(transport);
                    MapReduceWorker.Client client = new MapReduceWorker.Client(protocol);

                    List<KeyValueEntity> keyValueEntityBuffer = new ArrayList<>();

                    for(int i=0; i<keyValueEntityList.size();i++){
                        keyValueEntityBuffer.add(keyValueEntityList.get(i));
                        if((i+1) % workerConfiguration.getBufferSize() == 0 || (i+1) == keyValueEntityList.size()){
                            client.RegisterMapPair(keyValueEntityBuffer);
                            keyValueEntityBuffer.clear();
                        }
                    }
                    return "SUCCESS for " + workerId;
                }catch(Exception err){
                    System.out.println("Exception occurred during sending to workers");
                    err.printStackTrace();
                    return "ERROR for "+ workerId;
                }
            }
        }
    }


}