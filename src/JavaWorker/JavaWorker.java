package JavaWorker;

import Configuration.WorkerConfiguration;
import MapReduce.Thrift.AutoGenerated.ClientListeningInfo;
import MapReduce.Thrift.AutoGenerated.KeyValueEntity;
import MapReduce.Thrift.AutoGenerated.MapReduceMaster;
import MapReduce.Thrift.AutoGenerated.MapReduceWorker;
import MapReduce.Thrift.MapReduceWorkerHandler;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.Pair;
import org.apache.thrift.TException;
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.server.TServer;
import org.apache.thrift.server.TThreadPoolServer;
import org.apache.thrift.transport.*;
import sun.net.util.IPAddressUtil;

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import org.slf4j.*;


/**
 * Created by suchy on 28.05.2018.
 */

public class JavaWorker {

    private WorkerConfiguration workerConfiguration;

    public JavaWorker(WorkerConfiguration workerConfiguration){
        this.workerConfiguration = workerConfiguration;
    }

    public void start(){
        // creates fixed thread pool
        ExecutorService pool = Executors.newFixedThreadPool(2);


        DataSyncWrapper dataSyncWrapper = new DataSyncWrapper();
        try{
            // server runnable thread starts to execute
            pool.execute(new ServerCallClass(dataSyncWrapper,workerConfiguration));
            // client runnable thread starts to execute
            pool.execute(new ClientCallClass(dataSyncWrapper,workerConfiguration));
            if (!pool.awaitTermination(60, TimeUnit.MINUTES)){
                pool.shutdownNow();
            }

        } catch (InterruptedException e){
            System.out.println("Something went wrong with main threads");
        }
    }

    protected static class ServerCallClass implements Runnable
    {
        DataSyncWrapper dataSyncWrapper;
        WorkerConfiguration workerConfiguration;

        public static MapReduceWorkerHandler handler;
        public static MapReduceWorker.Processor processor;

        private ServerCallClass(DataSyncWrapper dataSyncWrapper, WorkerConfiguration workerConfiguration) {
            this.dataSyncWrapper = dataSyncWrapper;
            this.workerConfiguration = workerConfiguration;
        }

        public void run() {
            try {
                handler = new MapReduceWorkerHandler(dataSyncWrapper, workerConfiguration);
                processor = new MapReduceWorker.Processor<>(handler);
                TServerTransport serverTransport = new TServerSocket(new InetSocketAddress(workerConfiguration.getIp(),workerConfiguration.getListeningPort()));
                TServer server = new TThreadPoolServer(new TThreadPoolServer.Args(serverTransport).processor(processor));
                System.out.println("SERVER: Configuration ended.");
                dataSyncWrapper.endOfAction(true);

                System.out.println("SERVER: Starting the worker server...");
                server.serve(); // infinite loop inside

                System.out.println("SERVER: Worker Server Done.");
            } catch (TTransportException e) {
                System.out.println("SERVER: Thrift Transport Exception occurred!");
                e.printStackTrace();
            } catch(InterruptedException e) {
                System.out.println("SERVER: Interrupted Exception occurred!");
                e.printStackTrace();
            }
        }
    }

    protected class ClientCallClass implements Runnable
    {
        DataSyncWrapper dataSyncWrapper;
        WorkerConfiguration workerConfiguration;

        private ClientCallClass(DataSyncWrapper dataSyncWrapper, WorkerConfiguration workerConfiguration){
            this.dataSyncWrapper = dataSyncWrapper;
            this.workerConfiguration = workerConfiguration;
        }

        public void run() {
            try {
                System.out.println("CLIENT: Waiting for server configuration...");
                dataSyncWrapper.waitForServer();

                System.out.println("CLIENT: Started.");
                TTransport transport = new TSocket(workerConfiguration.getMasterIp(), workerConfiguration.getMasterPort());
                TProtocol protocol = new TBinaryProtocol(transport);
                MapReduceMaster.Client client = new MapReduceMaster.Client(protocol);
                System.out.println("CLIENT: Configuration ended.");

                System.out.println("CLIENT: Trying to open connection...");
                transport.open();
                System.out.println("CLIENT: Connection opened.");

                System.out.println("CLIENT: Trying to register Worker...");
                client.RegisterWorker(workerConfiguration.getIpInt(), workerConfiguration.getListeningPort());
                System.out.println("CLIENT: Register finished");

                System.out.println("CLIENT: Waiting for assigned work...");
                dataSyncWrapper.waitForServer();

                WorkerListManager workerListManager = new WorkerListManager(dataSyncWrapper.getWorkersConfigurationList().size(), dataSyncWrapper.getWorkersConfigurationList());

                //takes from workersQueue till the end (python putting)
                while (!dataSyncWrapper.IsEndOfRegisterWorkersQueue() || !dataSyncWrapper.isRegisterWorkersQueueEmpty()) {
                    workerListManager.add(dataSyncWrapper.takeFromRegisterWorkersQueue());
                    dataSyncWrapper.waitForServer();
                }

                System.out.println("CLIENT: Sending to workers and waiting for all threads...");
                sendToWorkersAndWait(workerListManager);

                System.out.println("CLIENT: Finish Map");
                client.FinishedMap();

                System.out.println("CLIENT: Waiting for start reduce...");
                dataSyncWrapper.waitForFinishReduce();

                System.out.println("CLIENT: Finish Reduce");
                client.FinishedReduce();

                System.out.println("CLIENT: Send Results");
                for(Pair<String,String> pair: dataSyncWrapper.getResultList()) {
                    //client.RegisterResult(pair.left, pair.right);
                }
                transport.close();
                System.out.println("CLIENT: Connection closed.");

            } catch (TException e) {
                System.out.println("CLIENT: Thrift Exception occurred!");
                e.printStackTrace();
            } catch (InterruptedException e) {
                System.out.println("CLIENT: Exception occurred during waiting for map results");
                e.printStackTrace();
            }
        }

        private void sendToWorkersAndWait(WorkerListManager workerListManager){
            List<Future<String>> threadListToWairFor = new ArrayList<>();
            ExecutorService executor= Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
            try{
                for (Integer workerId: workerListManager.getKeyValueEntityMap().keySet()){
                    ClientListeningInfo clientInfo = workerListManager.getClientListeningInfo(workerId);
                    NewThread newThread = new NewThread(clientInfo.getPort(),clientInfo.getIp(),workerListManager.getKeyValueEntityList(workerId));
                    Future<String> future = executor.submit(newThread);
                    threadListToWairFor.add(future);
                }
                //wait for all threads
                for(Future<String> fut : threadListToWairFor) {
                    try {
                        //Future.get() waits for task to get completed
                        System.out.println(fut.get());
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }
                }
            }catch(Exception err){
                err.printStackTrace();
            }
            executor.shutdown(); // once you are done with ExecutorService
        }

        private class NewThread implements Callable{
            int workerId;
            int port;
            int ip;
            List<KeyValueEntity> keyValueEntityList;

            public NewThread(int port, int ip, List<KeyValueEntity> keyValueEntityList){
                this.port = port;
                this.ip = Integer.reverseBytes(ip);
                this.keyValueEntityList = keyValueEntityList;
            }
            public String call(){
                try{
                    TTransport transport = new TSocket(InetAddress.getByAddress(ByteBuffer.allocate(4).putInt(ip).array()).getHostName(),port);
                    TProtocol protocol = new TBinaryProtocol(transport);
                    MapReduceWorker.Client client = new MapReduceWorker.Client(protocol);
                    transport.open();
                    List<KeyValueEntity> keyValueEntityBuffer = new ArrayList<>();

                    for(int i=0; i<keyValueEntityList.size();i++){
                        keyValueEntityBuffer.add(keyValueEntityList.get(i));
                        if((i+1) % workerConfiguration.getBufferSize() == 0 || (i+1) == keyValueEntityList.size()){
                            client.RegisterMapPair(keyValueEntityBuffer);
                            keyValueEntityBuffer.clear();
                        }
                    }
                    return "CLIENT thread for workerID:" + workerId + " ended with SUCCESS";
                }catch(Exception err){
                    System.out.println("CLIENT thread for workerID:" + workerId + " Exception occurred during sending to workers");
                    err.printStackTrace();
                    return "CLIENT thread for workerID:" + workerId + " ended with ERROR";
                }
            }
        }
    }


}